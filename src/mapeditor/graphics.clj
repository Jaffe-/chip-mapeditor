;; Chip's Challenge Map Editor
;;
;; Handling of graphics (tiles, metatiles)

(ns mapeditor.graphics
  (:require [clojure.java.io :as io]
            [mapeditor.util]))

(def palette-rgb-map
  '[(0x80 0x80 0x80) (0x00 0x3D 0xA6) (0x00 0x12 0xB0) (0x44 0x00 0x96)
  (0xA1 0x00 0x5E) (0xC7 0x00 0x28) (0xBA 0x06 0x00) (0x8C 0x17 0x00)
  (0x5C 0x2F 0x00) (0x10 0x45 0x00) (0x05 0x4A 0x00) (0x00 0x47 0x2E)
  (0x00 0x41 0x66) (0x00 0x00 0x00) (0x05 0x05 0x05) (0x05 0x05 0x05)
  (0xC7 0xC7 0xC7) (0x00 0x77 0xFF) (0x21 0x55 0xFF) (0x82 0x37 0xFA)
  (0xEB 0x2F 0xB5) (0xFF 0x29 0x50) (0xFF 0x22 0x00) (0xD6 0x32 0x00)
  (0xC4 0x62 0x00) (0x35 0x80 0x00) (0x05 0x8F 0x00) (0x00 0x8A 0x55)
  (0x00 0x99 0xCC) (0x21 0x21 0x21) (0x09 0x09 0x09) (0x09 0x09 0x09)
  (0xFF 0xFF 0xFF) (0x0F 0xD7 0xFF) (0x69 0xA2 0xFF) (0xD4 0x80 0xFF)
  (0xFF 0x45 0xF3) (0xFF 0x61 0x8B) (0xFF 0x88 0x33) (0xFF 0x9C 0x12)
  (0xFA 0xBC 0x20) (0x9F 0xE3 0x0E) (0x2B 0xF0 0x35) (0x0C 0xF0 0xA4)
  (0x05 0xFB 0xFF) (0x5E 0x5E 0x5E) (0x0D 0x0D 0x0D) (0x0D 0x0D 0x0D)
  (0xFF 0xFF 0xFF) (0xA6 0xFC 0xFF) (0x83 0xEC 0xFF) (0xDA 0xAB 0xEB)
  (0xFF 0xA8 0xF9) (0xFF 0xAB 0x83) (0xFF 0xD2 0xB0) (0xFF 0xEF 0xA6)
  (0xFF 0xF7 0x9C) (0xD7 0xE8 0x95) (0xA6 0xED 0xAF) (0xA2 0xF2 0xDA)
  (0x99 0xFF 0xFC) (0xDD 0xDD 0xDD) (0x11 0x11 0x11) (0x11 0x11 0x11)])

(def background-palette
  '[0x0E 0x00 0x10 0x20
    0x0E 0x11 0x2C 0x31
    0x0E 0x06 0x16 0x26
    0x0E 0x1A 0x2A 0x20])

(def sprite-palette
  '[0x00 0x3D 0x2D 0x00
    0x00 0x11 0x2C 0x20
    0x00 0x06 0x16 0x38
    0x00 0x09 0x19 0x3B])

;; Graphics loading

(defn- read-bytes
  "Read the bytes in the file given into a byte array"
  [filename]
  (with-open [in-stream (io/input-stream filename)]
    (doall ; this is to force evaluation when the file is open 
     (for [i (range 256)
           :let [bytes (byte-array 16)]]
       (do
         (.read in-stream bytes)
         bytes)))))

;; Tile functions

(defn- bytes->tile
  "Convert a NES format byte to a list of pixel colors (palette indices)"
  [bytes]
  (vec
   (let [[plane1 plane2] (split-in-half (map #(bit-array % 8) bytes))]
     (map (fn [row1 row2]
            (vec (map (fn [bit1 bit2]
                    (+ (* bit2 2) bit1))
                  row1 row2)))
          plane1 plane2))))

(defn read-tiles
  "Read all 256 tiles from CHR file"
  [chr-file]
  (when (= (.length (io/as-file chr-file)) 4096)
    (let [byte-arrays (read-bytes chr-file)]
      (vec (map bytes->tile byte-arrays)))))

(defn- compose-metatile
  "Put together a metatile based on a list of tiles"
  [tileset metatile-def]
  (apply concat
         (map #(map concat (first %) (second %))
              (split-in-half (map #(nth tileset %)
                                  metatile-def)))))

(defn- lookup-color
  "Take in a palette (sprite or background), palette number and palette index and find the resulting color"
  [palette palette-number palette-index]
  (nth palette-rgb-map
       (nth palette
            (+ palette-index (* palette-number 4)))))

(defn get-block-pixels
  "Get a list of the pixels of a metatile"
  [tileset palette {offset :tile-offset palette-number :palette}]
  (let [metatile (compose-metatile tileset (range offset (+ offset 4)))]
    (for [row metatile]
      (map #(lookup-color palette palette-number %) row))))

